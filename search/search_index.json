{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deethon \u00a4 Deethon is a lightweight Python library for downloading high quality music from Deezer. Gettings started \u00a4 Installation \u00a4 pip install deethon Usage \u00a4 import deethon deezer = deethon . Session ( \"YOUR ARL TOKEN\" ) deezer . download ( \"https://www.deezer.com/track/1234567\" , bitrate = \"FLAC\" # or MP3_320 / MP3_256 / MP3_128 (optional) )","title":"Welcome to Deethon"},{"location":"#deethon","text":"Deethon is a lightweight Python library for downloading high quality music from Deezer.","title":"Deethon"},{"location":"#gettings-started","text":"","title":"Gettings started"},{"location":"#installation","text":"pip install deethon","title":"Installation"},{"location":"#usage","text":"import deethon deezer = deethon . Session ( \"YOUR ARL TOKEN\" ) deezer . download ( \"https://www.deezer.com/track/1234567\" , bitrate = \"FLAC\" # or MP3_320 / MP3_256 / MP3_128 (optional) )","title":"Usage"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 0.4.3 - 2020-07-15 \u00a4 Added \u00a4 Additional tags to the track object and the downloaded tracks (lyrics, copyright, etc.) ( 880511b ). Fixed \u00a4 The session on Deezer will not be renewed after the expiration ( a82cb4a ). The ReplayGain tag had a wrong value ( 880511b ). 0.4.2 - 2020-06-18 \u00a4 Changed \u00a4 Return absolute file path ( c682537 ). Fixed \u00a4 Forbidden file name characters on Windows were not escaped ( 487393e ). 0.4.1 - 2020-06-08 \u00a4 Added \u00a4 Fallback to lower quality if the track cannot be downloaded ( ffe271e ). pytest-cov in dev-dependencies ( 56da09d ). Changed \u00a4 Exclude python files from .editorconfig as it causes code style errors ( 88e7708 ). Fixed \u00a4 Obsolete type annotations in docstrings ( fab7a84 ). Some layout bugs in the documentation. 0.4.0 - 2020-06-02 \u00a4 Added \u00a4 API documentation ( !9 ). Support for Python 3.7+ (again) ( 09f16e3 ). Raise [ DeezerLoginError ][deethon.errors.DeezerLoginError] when the specified arl token is invalid. ( c5b3693 ) More tests ( 52c29e9 ). .editorconfig file ( 2a9aff1 ). Changed \u00a4 Only accept an integer for the ID parameter of the album and track class. ( f335333 ) Fixed \u00a4 Invalid all-object ( cbb1e5d ). Useless object inheritance of Album class ( 05cb61e ). Code style issues ( ab13d39 ). __init__ method from base class Exception is not called ( 094d15a ). 0.3.3 - 2020-05-29 \u00a4 Added \u00a4 Raise [DeezerApiError][deethon.errors.DeezerApiError] when the specified album is not found ( 0458012 ). Stream option for album download ( c316814 ). 0.3.2 - 2020-05-27 \u00a4 Fixed \u00a4 ID3NoHeaderError when tagging MP3 files ( 5c79b5c ). 0.3.1 - 2020-05-27 \u00a4 Fixed \u00a4 The type of total bytes count should be int ( 0ebfd82 ). Stream the download while decrypting the track ( 0ebfd82 ) 0.3.0 - 2020-05-27 \u00a4 Added \u00a4 Optional progress callback ( 29df0e9 ) More type hints ( 04e67f4 ). 0.2.0 - 2020-05-27 \u00a4 Added \u00a4 Support for album download ( 276ce7c ). Caching of tracks and albums ( c69d8a3 ). More album cover options ( 783f8b3 ). Removed \u00a4 Support for Python 3.7 and earlier ( 3009e5f ). 0.1.1 - 2020-05-06 \u00a4 Changed \u00a4 Use regex for the download url ( 0cf6739 ). Fixed \u00a4 Wrong name of quality variable ( 399c1eb ). 0.1.0 - 2020-05-05 \u00a4 Added \u00a4 Initial release! \ud83c\udf89","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#043-2020-07-15","text":"","title":"0.4.3 - 2020-07-15"},{"location":"changelog/#added","text":"Additional tags to the track object and the downloaded tracks (lyrics, copyright, etc.) ( 880511b ).","title":"Added"},{"location":"changelog/#fixed","text":"The session on Deezer will not be renewed after the expiration ( a82cb4a ). The ReplayGain tag had a wrong value ( 880511b ).","title":"Fixed"},{"location":"changelog/#042-2020-06-18","text":"","title":"0.4.2 - 2020-06-18"},{"location":"changelog/#changed","text":"Return absolute file path ( c682537 ).","title":"Changed"},{"location":"changelog/#fixed_1","text":"Forbidden file name characters on Windows were not escaped ( 487393e ).","title":"Fixed"},{"location":"changelog/#041-2020-06-08","text":"","title":"0.4.1 - 2020-06-08"},{"location":"changelog/#added_1","text":"Fallback to lower quality if the track cannot be downloaded ( ffe271e ). pytest-cov in dev-dependencies ( 56da09d ).","title":"Added"},{"location":"changelog/#changed_1","text":"Exclude python files from .editorconfig as it causes code style errors ( 88e7708 ).","title":"Changed"},{"location":"changelog/#fixed_2","text":"Obsolete type annotations in docstrings ( fab7a84 ). Some layout bugs in the documentation.","title":"Fixed"},{"location":"changelog/#040-2020-06-02","text":"","title":"0.4.0 - 2020-06-02"},{"location":"changelog/#added_2","text":"API documentation ( !9 ). Support for Python 3.7+ (again) ( 09f16e3 ). Raise [ DeezerLoginError ][deethon.errors.DeezerLoginError] when the specified arl token is invalid. ( c5b3693 ) More tests ( 52c29e9 ). .editorconfig file ( 2a9aff1 ).","title":"Added"},{"location":"changelog/#changed_2","text":"Only accept an integer for the ID parameter of the album and track class. ( f335333 )","title":"Changed"},{"location":"changelog/#fixed_3","text":"Invalid all-object ( cbb1e5d ). Useless object inheritance of Album class ( 05cb61e ). Code style issues ( ab13d39 ). __init__ method from base class Exception is not called ( 094d15a ).","title":"Fixed"},{"location":"changelog/#033-2020-05-29","text":"","title":"0.3.3 - 2020-05-29"},{"location":"changelog/#added_3","text":"Raise [DeezerApiError][deethon.errors.DeezerApiError] when the specified album is not found ( 0458012 ). Stream option for album download ( c316814 ).","title":"Added"},{"location":"changelog/#032-2020-05-27","text":"","title":"0.3.2 - 2020-05-27"},{"location":"changelog/#fixed_4","text":"ID3NoHeaderError when tagging MP3 files ( 5c79b5c ).","title":"Fixed"},{"location":"changelog/#031-2020-05-27","text":"","title":"0.3.1 - 2020-05-27"},{"location":"changelog/#fixed_5","text":"The type of total bytes count should be int ( 0ebfd82 ). Stream the download while decrypting the track ( 0ebfd82 )","title":"Fixed"},{"location":"changelog/#030-2020-05-27","text":"","title":"0.3.0 - 2020-05-27"},{"location":"changelog/#added_4","text":"Optional progress callback ( 29df0e9 ) More type hints ( 04e67f4 ).","title":"Added"},{"location":"changelog/#020-2020-05-27","text":"","title":"0.2.0 - 2020-05-27"},{"location":"changelog/#added_5","text":"Support for album download ( 276ce7c ). Caching of tracks and albums ( c69d8a3 ). More album cover options ( 783f8b3 ).","title":"Added"},{"location":"changelog/#removed","text":"Support for Python 3.7 and earlier ( 3009e5f ).","title":"Removed"},{"location":"changelog/#011-2020-05-06","text":"","title":"0.1.1 - 2020-05-06"},{"location":"changelog/#changed_3","text":"Use regex for the download url ( 0cf6739 ).","title":"Changed"},{"location":"changelog/#fixed_6","text":"Wrong name of quality variable ( 399c1eb ).","title":"Fixed"},{"location":"changelog/#010-2020-05-05","text":"","title":"0.1.0 - 2020-05-05"},{"location":"changelog/#added_6","text":"Initial release! \ud83c\udf89","title":"Added"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at deethon@aykut.ml . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at deethon@aykut.ml . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"license/","text":"License \u00a4 Deethon - Python library to downlaod music from Deezer Copyright \u00a9 2020 Aykut Yilmaz This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"license/#license","text":"Deethon - Python library to downlaod music from Deezer Copyright \u00a9 2020 Aykut Yilmaz This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"reference/consts/","text":"\u00a4 This module contains several constants. API_URL: str \u00a4 The url of Deezer's unofficial API server. LEGACY_API_URL: str \u00a4 The url of Deezer's official API server. METHOD_GET_LYRICS: str \u00a4 The song.getLyrics method for the Deezer API request. METHOD_GET_TRACK: str \u00a4 The song.getData method for the Deezer API request. METHOD_GET_USER: str \u00a4 The deezer.getUserData method for the Deezer API request. METHOD_PAGE_TRACK: str \u00a4 The deezer.pageTrack method for the Deezer API request.","title":"consts.py"},{"location":"reference/consts/#deethon.consts","text":"This module contains several constants.","title":"deethon.consts"},{"location":"reference/consts/#deethon.consts.API_URL","text":"The url of Deezer's unofficial API server.","title":"API_URL"},{"location":"reference/consts/#deethon.consts.LEGACY_API_URL","text":"The url of Deezer's official API server.","title":"LEGACY_API_URL"},{"location":"reference/consts/#deethon.consts.METHOD_GET_LYRICS","text":"The song.getLyrics method for the Deezer API request.","title":"METHOD_GET_LYRICS"},{"location":"reference/consts/#deethon.consts.METHOD_GET_TRACK","text":"The song.getData method for the Deezer API request.","title":"METHOD_GET_TRACK"},{"location":"reference/consts/#deethon.consts.METHOD_GET_USER","text":"The deezer.getUserData method for the Deezer API request.","title":"METHOD_GET_USER"},{"location":"reference/consts/#deethon.consts.METHOD_PAGE_TRACK","text":"The deezer.pageTrack method for the Deezer API request.","title":"METHOD_PAGE_TRACK"},{"location":"reference/errors/","text":"\u00a4 The errors module contains all custom error classes ActionNotSupported \u00a4 Occurs when an invalid action is called. DeezerApiError \u00a4 Occurs when a Deezer API request replies with an error. DeezerLoginError \u00a4 Occurs when login to Deezer fails. DownloadError \u00a4 Occurs when a track cannot be downloaded. InvalidUrlError \u00a4 Occurs when an invalid URL is passed.","title":"errors.py"},{"location":"reference/errors/#deethon.errors","text":"The errors module contains all custom error classes","title":"deethon.errors"},{"location":"reference/errors/#deethon.errors.ActionNotSupported","text":"Occurs when an invalid action is called.","title":"ActionNotSupported"},{"location":"reference/errors/#deethon.errors.DeezerApiError","text":"Occurs when a Deezer API request replies with an error.","title":"DeezerApiError"},{"location":"reference/errors/#deethon.errors.DeezerLoginError","text":"Occurs when login to Deezer fails.","title":"DeezerLoginError"},{"location":"reference/errors/#deethon.errors.DownloadError","text":"Occurs when a track cannot be downloaded.","title":"DownloadError"},{"location":"reference/errors/#deethon.errors.InvalidUrlError","text":"Occurs when an invalid URL is passed.","title":"InvalidUrlError"},{"location":"reference/session/","text":"\u00a4 This module contains the Session class. Session \u00a4 A session is required to connect to Deezer's unofficial API. __init__ ( self , arl_token ) special \u00a4 Creates a new Deezer session instance. Parameters: Name Type Description Default arl_token str The arl token is used to make API requests on Deezer's unofficial API required Exceptions: Type Description DeezerLoginError The specified arl token is not valid. Source code in deethon/session.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , arl_token : str ): \"\"\" Creates a new Deezer session instance. Args: arl_token (str): The arl token is used to make API requests on Deezer's unofficial API Raises: DeezerLoginError: The specified arl token is not valid. \"\"\" self . _arl_token : str = arl_token self . _req = requests . Session () self . _req . cookies [ \"arl\" ] = self . _arl_token self . _csrf_token = \"null\" self . _session_expires = 0 download ( self , url , bitrate = 'FLAC' , progress_callback = None ) \u00a4 Downloads the given Deezer url if possible. Parameters: Name Type Description Default url str The URL of the track or album to download. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback Optional[Callable] A callable that accepts current and bytes arguments. None Exceptions: Type Description ActionNotSupported The specified URL is not (yet) supported for download. InvalidUrlError The specified URL is not a valid deezer link. Source code in deethon/session.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def download ( self , url : str , bitrate : str = \"FLAC\" , progress_callback : Optional [ Callable ] = None ): \"\"\" Downloads the given Deezer url if possible. Args: url: The URL of the track or album to download. bitrate: The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback (callable): A callable that accepts `current` and `bytes` arguments. Raises: ActionNotSupported: The specified URL is not (yet) supported for download. InvalidUrlError: The specified URL is not a valid deezer link. \"\"\" match = re . match ( r \"https?://(?:www\\.)?deezer\\.com/(?:\\w+/)?(\\w+)/(\\d+)\" , url ) if match : mode = match . group ( 1 ) content_id = int ( match . group ( 2 )) if mode == \"track\" : return self . download_track ( types . Track ( content_id ), bitrate , progress_callback ) if mode == \"album\" : return self . download_album ( types . Album ( content_id ), bitrate ) raise errors . ActionNotSupported ( mode ) raise errors . InvalidUrlError ( url ) download_album ( self , album , bitrate = None , stream = False ) \u00a4 Downloads an album from Deezer using the specified Album object. Parameters: Name Type Description Default album Album An [Album][deethon.types.Album] instance. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). None stream bool If true , this method returns a generator object, otherwise the downloaded files are returned as a tuple that contains the file paths. False Returns: Type Description Optional[Generator[pathlib.Path, Any], Tuple[pathlib.Path, ...]] The file paths. Source code in deethon/session.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def download_album ( self , album : types . Album , bitrate : str = None , stream : bool = False ) -> Union [ Generator [ Path , Any , None ], Tuple [ Path , ... ]]: \"\"\" Downloads an album from Deezer using the specified Album object. Args: album: An [Album][deethon.types.Album] instance. bitrate: The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). stream: If `true`, this method returns a generator object, otherwise the downloaded files are returned as a tuple that contains the file paths. Returns: The file paths. \"\"\" tracks = ( self . download_track ( track , bitrate ) for track in album . tracks ) if stream : return tracks return tuple ( tracks ) download_track ( self , track , bitrate = 'FLAC' , progress_callback = None ) \u00a4 Downloads the given [Track][deethon.types.Track] object. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback Optional[Callable] A callable that accepts current and bytes arguments. None Returns: Type Description Path The file path of the downloaded track. Exceptions: Type Description DownloadError The track is not downloadable. Source code in deethon/session.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def download_track ( self , track : types . Track , bitrate : str = \"FLAC\" , progress_callback : Optional [ Callable ] = None ) -> Path : \"\"\" Downloads the given [Track][deethon.types.Track] object. Args: track: A [Track][deethon.types.Track] instance. bitrate: The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback: A callable that accepts `current` and `bytes` arguments. Returns: The file path of the downloaded track. Raises: DownloadError: The track is not downloadable. \"\"\" track . add_more_tags ( self ) quality = utils . get_quality ( bitrate ) download_url = utils . get_stream_url ( track , quality ) crypt = self . _req . get ( download_url , stream = True ) total = int ( crypt . headers [ \"Content-Length\" ]) if not total : if bitrate == \"FLAC\" : fallback_bitrate = \"MP3_320\" elif bitrate == \"MP3_320\" : fallback_bitrate = \"MP3_256\" elif bitrate == \"MP3_256\" : fallback_bitrate = \"MP3_128\" else : raise errors . DownloadError ( track . id ) return self . download_track ( track , fallback_bitrate , progress_callback ) current = 0 ext = \".flac\" if quality == \"9\" else \".mp3\" file_path = utils . get_file_path ( track , ext ) with file_path . open ( \"wb\" ) as f : for data in utils . decrypt_file ( crypt . iter_content ( 2048 ), track . id ): current += len ( data ) f . write ( data ) if progress_callback : progress_callback ( current , total ) utils . tag ( file_path , track ) return file_path . absolute ()","title":"session.py"},{"location":"reference/session/#deethon.session","text":"This module contains the Session class.","title":"deethon.session"},{"location":"reference/session/#deethon.session.Session","text":"A session is required to connect to Deezer's unofficial API.","title":"Session"},{"location":"reference/session/#deethon.session.Session.__init__","text":"Creates a new Deezer session instance. Parameters: Name Type Description Default arl_token str The arl token is used to make API requests on Deezer's unofficial API required Exceptions: Type Description DeezerLoginError The specified arl token is not valid. Source code in deethon/session.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , arl_token : str ): \"\"\" Creates a new Deezer session instance. Args: arl_token (str): The arl token is used to make API requests on Deezer's unofficial API Raises: DeezerLoginError: The specified arl token is not valid. \"\"\" self . _arl_token : str = arl_token self . _req = requests . Session () self . _req . cookies [ \"arl\" ] = self . _arl_token self . _csrf_token = \"null\" self . _session_expires = 0","title":"__init__()"},{"location":"reference/session/#deethon.session.Session.download","text":"Downloads the given Deezer url if possible. Parameters: Name Type Description Default url str The URL of the track or album to download. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback Optional[Callable] A callable that accepts current and bytes arguments. None Exceptions: Type Description ActionNotSupported The specified URL is not (yet) supported for download. InvalidUrlError The specified URL is not a valid deezer link. Source code in deethon/session.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def download ( self , url : str , bitrate : str = \"FLAC\" , progress_callback : Optional [ Callable ] = None ): \"\"\" Downloads the given Deezer url if possible. Args: url: The URL of the track or album to download. bitrate: The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback (callable): A callable that accepts `current` and `bytes` arguments. Raises: ActionNotSupported: The specified URL is not (yet) supported for download. InvalidUrlError: The specified URL is not a valid deezer link. \"\"\" match = re . match ( r \"https?://(?:www\\.)?deezer\\.com/(?:\\w+/)?(\\w+)/(\\d+)\" , url ) if match : mode = match . group ( 1 ) content_id = int ( match . group ( 2 )) if mode == \"track\" : return self . download_track ( types . Track ( content_id ), bitrate , progress_callback ) if mode == \"album\" : return self . download_album ( types . Album ( content_id ), bitrate ) raise errors . ActionNotSupported ( mode ) raise errors . InvalidUrlError ( url )","title":"download()"},{"location":"reference/session/#deethon.session.Session.download_album","text":"Downloads an album from Deezer using the specified Album object. Parameters: Name Type Description Default album Album An [Album][deethon.types.Album] instance. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). None stream bool If true , this method returns a generator object, otherwise the downloaded files are returned as a tuple that contains the file paths. False Returns: Type Description Optional[Generator[pathlib.Path, Any], Tuple[pathlib.Path, ...]] The file paths. Source code in deethon/session.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def download_album ( self , album : types . Album , bitrate : str = None , stream : bool = False ) -> Union [ Generator [ Path , Any , None ], Tuple [ Path , ... ]]: \"\"\" Downloads an album from Deezer using the specified Album object. Args: album: An [Album][deethon.types.Album] instance. bitrate: The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). stream: If `true`, this method returns a generator object, otherwise the downloaded files are returned as a tuple that contains the file paths. Returns: The file paths. \"\"\" tracks = ( self . download_track ( track , bitrate ) for track in album . tracks ) if stream : return tracks return tuple ( tracks )","title":"download_album()"},{"location":"reference/session/#deethon.session.Session.download_track","text":"Downloads the given [Track][deethon.types.Track] object. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback Optional[Callable] A callable that accepts current and bytes arguments. None Returns: Type Description Path The file path of the downloaded track. Exceptions: Type Description DownloadError The track is not downloadable. Source code in deethon/session.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def download_track ( self , track : types . Track , bitrate : str = \"FLAC\" , progress_callback : Optional [ Callable ] = None ) -> Path : \"\"\" Downloads the given [Track][deethon.types.Track] object. Args: track: A [Track][deethon.types.Track] instance. bitrate: The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback: A callable that accepts `current` and `bytes` arguments. Returns: The file path of the downloaded track. Raises: DownloadError: The track is not downloadable. \"\"\" track . add_more_tags ( self ) quality = utils . get_quality ( bitrate ) download_url = utils . get_stream_url ( track , quality ) crypt = self . _req . get ( download_url , stream = True ) total = int ( crypt . headers [ \"Content-Length\" ]) if not total : if bitrate == \"FLAC\" : fallback_bitrate = \"MP3_320\" elif bitrate == \"MP3_320\" : fallback_bitrate = \"MP3_256\" elif bitrate == \"MP3_256\" : fallback_bitrate = \"MP3_128\" else : raise errors . DownloadError ( track . id ) return self . download_track ( track , fallback_bitrate , progress_callback ) current = 0 ext = \".flac\" if quality == \"9\" else \".mp3\" file_path = utils . get_file_path ( track , ext ) with file_path . open ( \"wb\" ) as f : for data in utils . decrypt_file ( crypt . iter_content ( 2048 ), track . id ): current += len ( data ) f . write ( data ) if progress_callback : progress_callback ( current , total ) utils . tag ( file_path , track ) return file_path . absolute ()","title":"download_track()"},{"location":"reference/types/","text":"\u00a4 This module contains all available type classes. Album \u00a4 The Album class contains several information about an album. Attributes: Name Type Description artist str The main artist of the album. basic_tracks_data List[Dict[str, Any]] A list that contains basic tracks data. cover_small_link str The link for the album cover in small size. cover_medium_link str The link for the album cover in medium size. cover_big_link str The link for the album cover in big size. cover_xl_link str The link for the album cover in xl size. duration int The duration in seconds of the album. genres List[str] A list of genres of the album. id int int The ID of the album. label str The label of the album. link str The Deezer link of the album. record_type str The record type of the album. release_date datetime The release date of the album. title str The title of the album. total_tracks int The total number of tracks in the album. upc str The Universal Product Code (UPC) of the album. cover_big: bytes property readonly \u00a4 The album cover in big size. cover_medium: bytes property readonly \u00a4 The album cover in medium size. cover_small: bytes property readonly \u00a4 The album cover in small size. cover_xl: bytes property readonly \u00a4 The album cover in xl size. tracks: list property readonly \u00a4 A list of [Track][deethon.types.Track] objects for each track in the album. __init__ ( self , album_id ) special \u00a4 Create a new album instance with the specified album ID. Parameters: Name Type Description Default album_id int The Deezer album ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon/types.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def __init__ ( self , album_id : int ): \"\"\" Create a new album instance with the specified album ID. Args: album_id: The Deezer album ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/album/ { album_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ \"error\" ][ \"type\" ], r [ \"error\" ][ \"message\" ], r [ \"error\" ][ \"code\" ]) self . artist = r [ \"artist\" ][ \"name\" ] self . basic_tracks_data = r [ \"tracks\" ][ \"data\" ] self . cover_small_link = r [ \"cover_small\" ] self . cover_medium_link = r [ \"cover_medium\" ] self . cover_big_link = r [ \"cover_big\" ] self . cover_xl_link = r [ \"cover_xl\" ] self . duration = r [ \"duration\" ] self . genres = [ genre [ \"name\" ] for genre in r [ \"genres\" ][ \"data\" ]] self . id = r [ \"id\" ] self . label = r [ \"label\" ] self . link = r [ \"link\" ] self . record_type = r [ \"record_type\" ] self . release_date = datetime . strptime ( r [ \"release_date\" ], \"%Y-%m- %d \" ) self . title = r [ \"title\" ] self . total_tracks = r [ \"nb_tracks\" ] self . upc = r [ \"upc\" ] __new__ ( cls , album_id ) special staticmethod \u00a4 If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Parameters: Name Type Description Default album_id int The Deezer album ID. required Source code in deethon/types.py 63 64 65 66 67 68 69 70 71 72 73 74 75 def __new__ ( cls , album_id : int ): \"\"\" If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Args: album_id: The Deezer album ID. \"\"\" if album_id not in cls . _cache . keys (): cls . _cache [ album_id ] = super ( Album , cls ) . __new__ ( cls ) return cls . _cache [ album_id ] Track \u00a4 The Track class contains several information about a track. Attributes: Name Type Description album_id int The Deezer album ID to which the track belongs. artist str The main artist of the track. artists List[str] A list of artists featured in the track. bpm int Beats per minute of the track. disk_number int The disc number of the track. duration int The duration of the track. id int The Deezer ID of the track. isrc str The International Standard Recording Code (ISRC) of the track. link str The Deezer link of the track. number int The position of the track. preview_link str The link to a 30 second preview of the track. rank int The rank of the track on Deezer replaygain_track_gain str The Replay Gain value of the track. release_date datetime The release date of the track. title str The title of the track. title_short str The short title of the track. md5_origin Optional[str] The md5 origin of the track. media_version Optional[str] The media version of the track. composer Optional[List[str]] The author of the track. author Optional[List[str]] A list of one or more authors of the track. lyrics Optional[str] The lyrics of the track. lyrics_sync Optional[List[Dict[str, str]]] The synchronized lyrics of the track. lyrics_copyrights Optional[str] Copyright information of the lyrics. lyrics_writers Optional[List[str]] A list of writers of the lyrics. Info md5_origin , media_version , composer , author and all lyrics* tags are only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None . album: Album property readonly \u00a4 Return an Album instance. __init__ ( self , track_id ) special \u00a4 Create a new track instance with the specified track ID. Parameters: Name Type Description Default track_id int The Deezer track ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon/types.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def __init__ ( self , track_id : int ): \"\"\" Create a new track instance with the specified track ID. Args: track_id: The Deezer track ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/track/ { track_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ \"error\" ][ \"type\" ], r [ \"error\" ][ \"message\" ], r [ \"error\" ][ \"code\" ]) self . album_id : int = r [ \"album\" ][ \"id\" ] self . artist = r [ \"artist\" ][ \"name\" ] self . artists = [ artist [ \"name\" ] for artist in r [ 'contributors' ]] self . bpm = r [ \"bpm\" ] self . disk_number = r [ \"disk_number\" ] self . duration = r [ \"duration\" ] self . id = r [ \"id\" ] self . isrc = r [ \"isrc\" ] self . link = r [ \"link\" ] self . number = r [ \"track_position\" ] self . preview_link = r [ \"preview\" ] self . rank = r [ \"rank\" ] self . replaygain_track_gain = f \" { (( r [ 'gain' ] + 18.4 ) * - 1 ) : .2f } dB\" self . release_date = datetime . strptime ( r [ \"release_date\" ], \"%Y-%m- %d \" ) self . title = r [ \"title\" ] self . title_short = r [ \"title_short\" ] __new__ ( cls , track_id ) special staticmethod \u00a4 If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Parameters: Name Type Description Default track_id int The Deezer album ID. required Source code in deethon/types.py 215 216 217 218 219 220 221 222 223 224 225 226 227 def __new__ ( cls , track_id : int ): \"\"\" If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Args: track_id: The Deezer album ID. \"\"\" if track_id not in cls . _cache . keys (): cls . _cache [ track_id ] = super ( Track , cls ) . __new__ ( cls ) return cls . _cache [ track_id ] add_more_tags ( self , session ) \u00a4 Adds more tags using Deezer's unofficial API. Parameters: Name Type Description Default session Session A [Session][deethon.session.Session] object is required to connect to the Deezer API. required Source code in deethon/types.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def add_more_tags ( self , session : Session ) -> None : \"\"\" Adds more tags using Deezer's unofficial API. Args: session: A [Session][deethon.session.Session] object is required to connect to the Deezer API. \"\"\" r = session . get_api ( consts . METHOD_PAGE_TRACK , { \"sng_id\" : self . id } ) self . md5_origin = r [ \"DATA\" ][ \"MD5_ORIGIN\" ] self . media_version = r [ \"DATA\" ][ \"MEDIA_VERSION\" ] self . composer = r [ \"DATA\" ][ \"SNG_CONTRIBUTORS\" ] . get ( \"composer\" ) self . author = r [ \"DATA\" ][ \"SNG_CONTRIBUTORS\" ] . get ( \"author\" ) self . copyright = r [ \"DATA\" ][ \"COPYRIGHT\" ] if \"LYRICS\" in r . keys (): self . lyrics = r [ \"LYRICS\" ] . get ( 'LYRICS_TEXT' ) self . lyrics_sync = r [ \"LYRICS\" ] . get ( 'LYRICS_SYNC_JSON' ) self . lyrics_copyrights = r [ \"LYRICS\" ] . get ( 'LYRICS_COPYRIGHTS' ) self . lyrics_writers = r [ \"LYRICS\" ] . get ( 'LYRICS_WRITERS' ) . split ( ', ' ) else : self . lyrics = None self . lyrics_sync = None self . lyrics_copyrights = None self . lyrics_writers = None","title":"types.py"},{"location":"reference/types/#deethon.types","text":"This module contains all available type classes.","title":"deethon.types"},{"location":"reference/types/#deethon.types.Album","text":"The Album class contains several information about an album. Attributes: Name Type Description artist str The main artist of the album. basic_tracks_data List[Dict[str, Any]] A list that contains basic tracks data. cover_small_link str The link for the album cover in small size. cover_medium_link str The link for the album cover in medium size. cover_big_link str The link for the album cover in big size. cover_xl_link str The link for the album cover in xl size. duration int The duration in seconds of the album. genres List[str] A list of genres of the album. id int int The ID of the album. label str The label of the album. link str The Deezer link of the album. record_type str The record type of the album. release_date datetime The release date of the album. title str The title of the album. total_tracks int The total number of tracks in the album. upc str The Universal Product Code (UPC) of the album.","title":"Album"},{"location":"reference/types/#deethon.types.Album.cover_big","text":"The album cover in big size.","title":"cover_big"},{"location":"reference/types/#deethon.types.Album.cover_medium","text":"The album cover in medium size.","title":"cover_medium"},{"location":"reference/types/#deethon.types.Album.cover_small","text":"The album cover in small size.","title":"cover_small"},{"location":"reference/types/#deethon.types.Album.cover_xl","text":"The album cover in xl size.","title":"cover_xl"},{"location":"reference/types/#deethon.types.Album.tracks","text":"A list of [Track][deethon.types.Track] objects for each track in the album.","title":"tracks"},{"location":"reference/types/#deethon.types.Album.__init__","text":"Create a new album instance with the specified album ID. Parameters: Name Type Description Default album_id int The Deezer album ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon/types.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def __init__ ( self , album_id : int ): \"\"\" Create a new album instance with the specified album ID. Args: album_id: The Deezer album ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/album/ { album_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ \"error\" ][ \"type\" ], r [ \"error\" ][ \"message\" ], r [ \"error\" ][ \"code\" ]) self . artist = r [ \"artist\" ][ \"name\" ] self . basic_tracks_data = r [ \"tracks\" ][ \"data\" ] self . cover_small_link = r [ \"cover_small\" ] self . cover_medium_link = r [ \"cover_medium\" ] self . cover_big_link = r [ \"cover_big\" ] self . cover_xl_link = r [ \"cover_xl\" ] self . duration = r [ \"duration\" ] self . genres = [ genre [ \"name\" ] for genre in r [ \"genres\" ][ \"data\" ]] self . id = r [ \"id\" ] self . label = r [ \"label\" ] self . link = r [ \"link\" ] self . record_type = r [ \"record_type\" ] self . release_date = datetime . strptime ( r [ \"release_date\" ], \"%Y-%m- %d \" ) self . title = r [ \"title\" ] self . total_tracks = r [ \"nb_tracks\" ] self . upc = r [ \"upc\" ]","title":"__init__()"},{"location":"reference/types/#deethon.types.Album.__new__","text":"If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Parameters: Name Type Description Default album_id int The Deezer album ID. required Source code in deethon/types.py 63 64 65 66 67 68 69 70 71 72 73 74 75 def __new__ ( cls , album_id : int ): \"\"\" If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Args: album_id: The Deezer album ID. \"\"\" if album_id not in cls . _cache . keys (): cls . _cache [ album_id ] = super ( Album , cls ) . __new__ ( cls ) return cls . _cache [ album_id ]","title":"__new__()"},{"location":"reference/types/#deethon.types.Track","text":"The Track class contains several information about a track. Attributes: Name Type Description album_id int The Deezer album ID to which the track belongs. artist str The main artist of the track. artists List[str] A list of artists featured in the track. bpm int Beats per minute of the track. disk_number int The disc number of the track. duration int The duration of the track. id int The Deezer ID of the track. isrc str The International Standard Recording Code (ISRC) of the track. link str The Deezer link of the track. number int The position of the track. preview_link str The link to a 30 second preview of the track. rank int The rank of the track on Deezer replaygain_track_gain str The Replay Gain value of the track. release_date datetime The release date of the track. title str The title of the track. title_short str The short title of the track. md5_origin Optional[str] The md5 origin of the track. media_version Optional[str] The media version of the track. composer Optional[List[str]] The author of the track. author Optional[List[str]] A list of one or more authors of the track. lyrics Optional[str] The lyrics of the track. lyrics_sync Optional[List[Dict[str, str]]] The synchronized lyrics of the track. lyrics_copyrights Optional[str] Copyright information of the lyrics. lyrics_writers Optional[List[str]] A list of writers of the lyrics. Info md5_origin , media_version , composer , author and all lyrics* tags are only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None .","title":"Track"},{"location":"reference/types/#deethon.types.Track.album","text":"Return an Album instance.","title":"album"},{"location":"reference/types/#deethon.types.Track.__init__","text":"Create a new track instance with the specified track ID. Parameters: Name Type Description Default track_id int The Deezer track ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon/types.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def __init__ ( self , track_id : int ): \"\"\" Create a new track instance with the specified track ID. Args: track_id: The Deezer track ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/track/ { track_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ \"error\" ][ \"type\" ], r [ \"error\" ][ \"message\" ], r [ \"error\" ][ \"code\" ]) self . album_id : int = r [ \"album\" ][ \"id\" ] self . artist = r [ \"artist\" ][ \"name\" ] self . artists = [ artist [ \"name\" ] for artist in r [ 'contributors' ]] self . bpm = r [ \"bpm\" ] self . disk_number = r [ \"disk_number\" ] self . duration = r [ \"duration\" ] self . id = r [ \"id\" ] self . isrc = r [ \"isrc\" ] self . link = r [ \"link\" ] self . number = r [ \"track_position\" ] self . preview_link = r [ \"preview\" ] self . rank = r [ \"rank\" ] self . replaygain_track_gain = f \" { (( r [ 'gain' ] + 18.4 ) * - 1 ) : .2f } dB\" self . release_date = datetime . strptime ( r [ \"release_date\" ], \"%Y-%m- %d \" ) self . title = r [ \"title\" ] self . title_short = r [ \"title_short\" ]","title":"__init__()"},{"location":"reference/types/#deethon.types.Track.__new__","text":"If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Parameters: Name Type Description Default track_id int The Deezer album ID. required Source code in deethon/types.py 215 216 217 218 219 220 221 222 223 224 225 226 227 def __new__ ( cls , track_id : int ): \"\"\" If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Args: track_id: The Deezer album ID. \"\"\" if track_id not in cls . _cache . keys (): cls . _cache [ track_id ] = super ( Track , cls ) . __new__ ( cls ) return cls . _cache [ track_id ]","title":"__new__()"},{"location":"reference/types/#deethon.types.Track.add_more_tags","text":"Adds more tags using Deezer's unofficial API. Parameters: Name Type Description Default session Session A [Session][deethon.session.Session] object is required to connect to the Deezer API. required Source code in deethon/types.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def add_more_tags ( self , session : Session ) -> None : \"\"\" Adds more tags using Deezer's unofficial API. Args: session: A [Session][deethon.session.Session] object is required to connect to the Deezer API. \"\"\" r = session . get_api ( consts . METHOD_PAGE_TRACK , { \"sng_id\" : self . id } ) self . md5_origin = r [ \"DATA\" ][ \"MD5_ORIGIN\" ] self . media_version = r [ \"DATA\" ][ \"MEDIA_VERSION\" ] self . composer = r [ \"DATA\" ][ \"SNG_CONTRIBUTORS\" ] . get ( \"composer\" ) self . author = r [ \"DATA\" ][ \"SNG_CONTRIBUTORS\" ] . get ( \"author\" ) self . copyright = r [ \"DATA\" ][ \"COPYRIGHT\" ] if \"LYRICS\" in r . keys (): self . lyrics = r [ \"LYRICS\" ] . get ( 'LYRICS_TEXT' ) self . lyrics_sync = r [ \"LYRICS\" ] . get ( 'LYRICS_SYNC_JSON' ) self . lyrics_copyrights = r [ \"LYRICS\" ] . get ( 'LYRICS_COPYRIGHTS' ) self . lyrics_writers = r [ \"LYRICS\" ] . get ( 'LYRICS_WRITERS' ) . split ( ', ' ) else : self . lyrics = None self . lyrics_sync = None self . lyrics_copyrights = None self . lyrics_writers = None","title":"add_more_tags()"},{"location":"reference/utils/","text":"\u00a4 The utils module contains several useful functions that are used within the package. decrypt_file ( input_data , track_id ) \u00a4 Decrypt an encrypted track. Parameters: Name Type Description Default input_data Iterator The input stream must have a chunk size of 2048. required track_id int The id of the track to be decrypted. required Returns: Type Description Generator[bytes, Any, None] A Generator object containing the decrypted data Source code in deethon/utils.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def decrypt_file ( input_data : Iterator , track_id : int ) -> Generator [ bytes , Any , None ]: \"\"\" Decrypt an encrypted track. Args: input_data: The input stream must have a chunk size of 2048. track_id: The id of the track to be decrypted. Returns: A Generator object containing the decrypted data \"\"\" h = md5hex ( str ( track_id ) . encode ()) key = \"\" . join ( chr ( h [ i ] ^ h [ i + 16 ] ^ b \"g4el58wc0zvf9na1\" [ i ]) for i in range ( 16 )) seg = 0 for data in input_data : if ( seg % 3 ) == 0 and len ( data ) == 2048 : data = Blowfish . new ( key . encode (), Blowfish . MODE_CBC , a2b_hex ( \"0001020304050607\" )) . decrypt ( data ) seg += 1 yield data get_file_path ( track , ext ) \u00a4 Generate a file path using a Track object. Parameters: Name Type Description Default track Track A Track object. required ext str The file extension to be used. required Returns: Type Description Path A Path object containing the track path. Source code in deethon/utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def get_file_path ( track : Track , ext : str ) -> Path : \"\"\" Generate a file path using a Track object. Args: track: A Track object. ext: The file extension to be used. Returns: A Path object containing the track path. \"\"\" forbidden_chars = dict (( ord ( char ), None ) for char in r '\\/*?:\"<>|' ) album_artist = track . album . artist . translate ( forbidden_chars ) album_title = track . album . title . translate ( forbidden_chars ) std_dir = \"Songs\" dir_path = Path ( std_dir , album_artist , album_title ) dir_path . mkdir ( parents = True , exist_ok = True ) file_name = f \" { track . number : 02 } { track . title }{ ext } \" return dir_path / file_name . translate ( forbidden_chars ) get_stream_url ( track , quality ) \u00a4 Get the direct download url for the encrypted track. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required quality str The preferred quality. required Returns: Type Description str The direct download url. Source code in deethon/utils.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_stream_url ( track : Track , quality : str ) -> str : \"\"\" Get the direct download url for the encrypted track. Args: track: A [Track][deethon.types.Track] instance. quality: The preferred quality. Returns: The direct download url. \"\"\" data = b \" \\xa4 \" . join ( a . encode () for a in [ track . md5_origin , quality , str ( track . id ), track . media_version ] ) data = b \" \\xa4 \" . join ([ md5hex ( data ), data ]) + b \" \\xa4 \" if len ( data ) % 16 : data += b \" \\x00 \" * ( 16 - len ( data ) % 16 ) c = AES . new ( \"jo6aey6haid2Teih\" . encode (), AES . MODE_ECB ) hashs = b2a_hex ( c . encrypt ( data )) . decode () return f \"https://e-cdns-proxy- { track . md5_origin [ 0 ] } .dzcdn.net/mobile/1/ { hashs } \" tag ( file_path , track ) \u00a4 Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Parameters: Name Type Description Default file_path Path The music file to be tagged required track Track The [Track][deethon.types.Track] instance to be used for tagging. required Source code in deethon/utils.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def tag ( file_path : Path , track : Track ) -> None : \"\"\" Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Args: file_path (Path): The music file to be tagged track: The [Track][deethon.types.Track] instance to be used for tagging. \"\"\" ext = file_path . suffix if ext == \".mp3\" : tags = ID3 () tags . clear () tags . add ( Frames [ \"TALB\" ]( encoding = 3 , text = track . album . title )) tags . add ( Frames [ \"TBPM\" ]( encoding = 3 , text = str ( track . bpm ))) tags . add ( Frames [ \"TCON\" ]( encoding = 3 , text = track . album . genres )) tags . add ( Frames [ \"TCOP\" ]( encoding = 3 , text = track . copyright )) tags . add ( Frames [ \"TDAT\" ]( encoding = 3 , text = track . release_date . strftime ( \" %d %m\" ))) tags . add ( Frames [ \"TIT2\" ]( encoding = 3 , text = track . title )) tags . add ( Frames [ \"TPE1\" ]( encoding = 3 , text = track . artist )) tags . add ( Frames [ \"TPE2\" ]( encoding = 3 , text = track . album . artist )) tags . add ( Frames [ \"TPOS\" ]( encoding = 3 , text = str ( track . disk_number ))) tags . add ( Frames [ \"TPUB\" ]( encoding = 3 , text = track . album . label )) tags . add ( Frames [ \"TRCK\" ]( encoding = 3 , text = f \" { track . number } / { track . album . total_tracks } \" )) tags . add ( Frames [ \"TSRC\" ]( encoding = 3 , text = track . isrc )) tags . add ( Frames [ \"TYER\" ]( encoding = 3 , text = str ( track . release_date . year ))) tags . add ( Frames [ \"TXXX\" ]( encoding = 3 , desc = \"replaygain_track_gain\" , text = str ( track . replaygain_track_gain ))) if track . lyrics : tags . add ( Frames [ \"USLT\" ]( encoding = 3 , text = track . lyrics )) tags . add ( Frames [ \"APIC\" ]( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = track . album . cover_xl )) tags . save ( file_path , v2_version = 3 ) else : tags = FLAC ( file_path ) tags . clear () tags [ \"album\" ] = track . album . title tags [ \"albumartist\" ] = track . album . artist tags [ \"artist\" ] = track . artist tags [ \"bpm\" ] = str ( track . bpm ) tags [ \"copyright\" ] = track . copyright tags [ \"date\" ] = track . release_date . strftime ( \"%Y-%m- %d \" ) tags [ \"genre\" ] = track . album . genres tags [ \"isrc\" ] = track . isrc if track . lyrics : tags [ \"lyrics\" ] = track . lyrics tags [ \"replaygain_track_gain\" ] = str ( track . replaygain_track_gain ) tags [ \"title\" ] = track . title tags [ \"tracknumber\" ] = str ( track . number ) tags [ \"year\" ] = str ( track . release_date . year ) cover = Picture () cover . type = 3 cover . data = track . album . cover_xl cover . width = 1000 cover . height = 1000 tags . clear_pictures () tags . add_picture ( cover ) tags . save ( deleteid3 = True )","title":"utils.py"},{"location":"reference/utils/#deethon.utils","text":"The utils module contains several useful functions that are used within the package.","title":"deethon.utils"},{"location":"reference/utils/#deethon.utils.decrypt_file","text":"Decrypt an encrypted track. Parameters: Name Type Description Default input_data Iterator The input stream must have a chunk size of 2048. required track_id int The id of the track to be decrypted. required Returns: Type Description Generator[bytes, Any, None] A Generator object containing the decrypted data Source code in deethon/utils.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def decrypt_file ( input_data : Iterator , track_id : int ) -> Generator [ bytes , Any , None ]: \"\"\" Decrypt an encrypted track. Args: input_data: The input stream must have a chunk size of 2048. track_id: The id of the track to be decrypted. Returns: A Generator object containing the decrypted data \"\"\" h = md5hex ( str ( track_id ) . encode ()) key = \"\" . join ( chr ( h [ i ] ^ h [ i + 16 ] ^ b \"g4el58wc0zvf9na1\" [ i ]) for i in range ( 16 )) seg = 0 for data in input_data : if ( seg % 3 ) == 0 and len ( data ) == 2048 : data = Blowfish . new ( key . encode (), Blowfish . MODE_CBC , a2b_hex ( \"0001020304050607\" )) . decrypt ( data ) seg += 1 yield data","title":"decrypt_file()"},{"location":"reference/utils/#deethon.utils.get_file_path","text":"Generate a file path using a Track object. Parameters: Name Type Description Default track Track A Track object. required ext str The file extension to be used. required Returns: Type Description Path A Path object containing the track path. Source code in deethon/utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def get_file_path ( track : Track , ext : str ) -> Path : \"\"\" Generate a file path using a Track object. Args: track: A Track object. ext: The file extension to be used. Returns: A Path object containing the track path. \"\"\" forbidden_chars = dict (( ord ( char ), None ) for char in r '\\/*?:\"<>|' ) album_artist = track . album . artist . translate ( forbidden_chars ) album_title = track . album . title . translate ( forbidden_chars ) std_dir = \"Songs\" dir_path = Path ( std_dir , album_artist , album_title ) dir_path . mkdir ( parents = True , exist_ok = True ) file_name = f \" { track . number : 02 } { track . title }{ ext } \" return dir_path / file_name . translate ( forbidden_chars )","title":"get_file_path()"},{"location":"reference/utils/#deethon.utils.get_stream_url","text":"Get the direct download url for the encrypted track. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required quality str The preferred quality. required Returns: Type Description str The direct download url. Source code in deethon/utils.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_stream_url ( track : Track , quality : str ) -> str : \"\"\" Get the direct download url for the encrypted track. Args: track: A [Track][deethon.types.Track] instance. quality: The preferred quality. Returns: The direct download url. \"\"\" data = b \" \\xa4 \" . join ( a . encode () for a in [ track . md5_origin , quality , str ( track . id ), track . media_version ] ) data = b \" \\xa4 \" . join ([ md5hex ( data ), data ]) + b \" \\xa4 \" if len ( data ) % 16 : data += b \" \\x00 \" * ( 16 - len ( data ) % 16 ) c = AES . new ( \"jo6aey6haid2Teih\" . encode (), AES . MODE_ECB ) hashs = b2a_hex ( c . encrypt ( data )) . decode () return f \"https://e-cdns-proxy- { track . md5_origin [ 0 ] } .dzcdn.net/mobile/1/ { hashs } \"","title":"get_stream_url()"},{"location":"reference/utils/#deethon.utils.tag","text":"Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Parameters: Name Type Description Default file_path Path The music file to be tagged required track Track The [Track][deethon.types.Track] instance to be used for tagging. required Source code in deethon/utils.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def tag ( file_path : Path , track : Track ) -> None : \"\"\" Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Args: file_path (Path): The music file to be tagged track: The [Track][deethon.types.Track] instance to be used for tagging. \"\"\" ext = file_path . suffix if ext == \".mp3\" : tags = ID3 () tags . clear () tags . add ( Frames [ \"TALB\" ]( encoding = 3 , text = track . album . title )) tags . add ( Frames [ \"TBPM\" ]( encoding = 3 , text = str ( track . bpm ))) tags . add ( Frames [ \"TCON\" ]( encoding = 3 , text = track . album . genres )) tags . add ( Frames [ \"TCOP\" ]( encoding = 3 , text = track . copyright )) tags . add ( Frames [ \"TDAT\" ]( encoding = 3 , text = track . release_date . strftime ( \" %d %m\" ))) tags . add ( Frames [ \"TIT2\" ]( encoding = 3 , text = track . title )) tags . add ( Frames [ \"TPE1\" ]( encoding = 3 , text = track . artist )) tags . add ( Frames [ \"TPE2\" ]( encoding = 3 , text = track . album . artist )) tags . add ( Frames [ \"TPOS\" ]( encoding = 3 , text = str ( track . disk_number ))) tags . add ( Frames [ \"TPUB\" ]( encoding = 3 , text = track . album . label )) tags . add ( Frames [ \"TRCK\" ]( encoding = 3 , text = f \" { track . number } / { track . album . total_tracks } \" )) tags . add ( Frames [ \"TSRC\" ]( encoding = 3 , text = track . isrc )) tags . add ( Frames [ \"TYER\" ]( encoding = 3 , text = str ( track . release_date . year ))) tags . add ( Frames [ \"TXXX\" ]( encoding = 3 , desc = \"replaygain_track_gain\" , text = str ( track . replaygain_track_gain ))) if track . lyrics : tags . add ( Frames [ \"USLT\" ]( encoding = 3 , text = track . lyrics )) tags . add ( Frames [ \"APIC\" ]( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = track . album . cover_xl )) tags . save ( file_path , v2_version = 3 ) else : tags = FLAC ( file_path ) tags . clear () tags [ \"album\" ] = track . album . title tags [ \"albumartist\" ] = track . album . artist tags [ \"artist\" ] = track . artist tags [ \"bpm\" ] = str ( track . bpm ) tags [ \"copyright\" ] = track . copyright tags [ \"date\" ] = track . release_date . strftime ( \"%Y-%m- %d \" ) tags [ \"genre\" ] = track . album . genres tags [ \"isrc\" ] = track . isrc if track . lyrics : tags [ \"lyrics\" ] = track . lyrics tags [ \"replaygain_track_gain\" ] = str ( track . replaygain_track_gain ) tags [ \"title\" ] = track . title tags [ \"tracknumber\" ] = str ( track . number ) tags [ \"year\" ] = str ( track . release_date . year ) cover = Picture () cover . type = 3 cover . data = track . album . cover_xl cover . width = 1000 cover . height = 1000 tags . clear_pictures () tags . add_picture ( cover ) tags . save ( deleteid3 = True )","title":"tag()"}]}